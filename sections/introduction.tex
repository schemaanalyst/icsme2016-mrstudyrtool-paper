%!TEX root=../icsme2016-mrstudyr.tex

\section{Introduction}

% Determining the quality of a test suite illustrates how stringently the
% given program was tested.

% Introduce software testing

Software developers may introduce errors into a program's source code that could result in a human
fatality~\cite{vicente2003programming}. Running a set of tests, frequently called a test suite, often aids in detecting
the faults that cause a program to function incorrectly~\cite{wagner2005comparing}. Yet, simply testing a program is not
sufficient. In order for testing to establish a high confidence in the correctness of the program under test, the test
suite needs to be of ``high quality''.

% Introduce mutation testing and its benefits

Mutation testing is a widely-recognized technique for assessing the quality of a test suite~\cite{gopinath2015mutation}.
While there are many potential faults for a program, mutation testing focuses on those that are ``close'' to the correct
version, with the expectation that they will be representative of all faults~\cite{jia2011analysis}. Of the methods for
evaluating test quality, mutation testing is widely considered the strongest test criterion in terms of its capability
to necessitate the creation of tests that find many faults~\cite{ammann2008introduction}.

% Talk about the limitations of mutation testing

Although mutation testing effectively requires tests to detect faults, it possesses major drawbacks in its computational
cost and the amount of human interaction it requires, often making it impractical to use~\cite{gopinath2015mutation,
wong1995reducing, gopinath2015empirical}.  A major computational cost of mutation testing comes from executing each test
case in a test suite for the many generated mutants~\cite{offutt1993experimental}. Executing a small, representative set
of mutants against the test suite has previously been proposed as a technique to reduce the cost of mutation
testing~\cite{jia2011analysis, wong1995reducing, offutt1993experimental}; this reduction strategy is categorized by
Offutt and Untch as a ``do fewer'' approach~\cite{offutt2001mutation}.

% Introduce the technique call random mutant sampling

There are several mutant reduction techniques in the ``do fewer'' category, with mutant sampling being a simple method
that randomly selects a subset of all mutants~\cite{wong1995reducing}.  Due to its simplicity, mutant sampling is
considered to be the most cost-effective reduction technique by avoiding implementation
complexities~\cite{gopinath2015mutation}.  Although it is simple to implement, mutant sampling has still been
empirically shown to outperform other techniques~\cite{zhang2010operator}.

Two sub-techniques within mutant sampling are uniform random sampling and sampling over
operators~\cite{gopinath2015mutation, gopinath2015empirical}.  For each sub-technique, a threshold for the maximum
number of mutants is set by an arbitrary $x$---the percentage of all mutants.  This $x$ is either applied to the entire
set of mutants or each set of mutants subsumed under an operator for uniform random sampling or sampling over operators,
respectively~\cite{gopinath2015mutation, gopinath2015empirical}.

Work has been done to find the smallest $x$ that still produces
a representative set of mutants~\cite{jia2011analysis, mathur1994empirical}. Prior work
attempting to find a representative set has been done by integrating a reduction technique into
a mutation testing system and to then perform mutation testing~\cite{demillo1988extended, king1991fortran}.

While this way of evaluating reduction techniques is accurate, it is both
expensive to implement and perform due to the number of times mutation testing
needs to be executed. Retrospectively studying the data
collected from a single execution of mutation testing is superior
because of its minimal upfront costs and the implementation complexities of
a target environment are obviated.

Since studying the data retrospectively removes the need to fathom the complexities of a target environment,
mutation testing can be extended to new domains (e.g., testing database schemas)~\cite{mcminn2016virtual, mcminn2015effectiveness, wright2013efficient}.
Testing that a relational database's schema has correctly specified integrity constraints is important
because these restrictions ensure that only valid data enters the database. However, little work has
sought to test these integrity constraints~\cite{mcminn2016virtual}.

Databases are utilized pervasively for storing everything from batting and pitching statistics of baseball
players~\cite{lahmanbaseball} to fingerprints and scars of criminals~\cite{ngi}.
Relational databases are an efficient and reliable way to store large amounts of data.
The acceptance of relationships between data entries, as well as strict structural constraints
upheld by the schema are what make relational databases unique.

The database's schema is the artefact responsible for specifying the data to be stored and
how it should be structured into tables. A series of integrity constraints
is what make the database's schema able to ensure values are unique, present,
subject to domain-specific conditions and maintain referential integrity~\cite{mcminn2016virtual}.
Although the schema is the last line of defence for the data contained
within a database, little work has sought to test the correctness of the integrity constraints~\cite{mcminn2015effectiveness}.

\input{figures/process}

% of database schemas~\cite{stackexchange}. Therefore, ensuring that

The little work testing the integrity constraints of a schema is not
because of a sufficient understanding of the topic. The 941,910 questions posted on
the technical question and answer website, StackExchange, indicate the demand for support
of database schemas~\footnote{http://goo.gl/eZF1mK}. Therefore, ensuring that
the schemas that are created are also tested is important in upholding the integrity
of the data contained within the database.

Due to its versatility, mutation testing can be used to detect errors made by programmers in many domains.
A domain that mutation testing has become more prominent in recently is testing database
schemas~\cite{mcminn2016virtual, mcminn2015effectiveness, wright2013efficient}. However,
due to its computation expense, it is not widely adopted in industry to test database schemas.
Although mutation testing is used in a variety of domains, the reduction techniques can still
be utilized, including retrospective analysis~\cite{jia2011analysis, wong1995reducing, offutt1993experimental, offutt2001mutation}.

Retrospective analysis is more cost-effective than applying a
mutant reduction technique and then evaluating it.
This is the case because the expense of mutation testing in
retrospective analysis is incurred only once, rather than for
every reduction technique. Analysing the effectiveness of an approach retrospectively
is possible because the necessary data can be collected from a prior analysis of all mutants.
This paper introduces \mr, the first and only tool that analyses reduction techniques retrospectively.

\mr is a tool for evaluating the effectiveness of mutation analysis reduction techniques
in retrospect. Using data in a generalised format from a single execution of mutation testing, \mr
employs each reduction strategy and performs calculations to determine the efficiency and
effectiveness. By accepting a generalised input format, \mr is capable of
retrospectively analysing mutant reduction techniques for various domains.
Additionally, \mr is modifiable, well-documented and has been released on
GitHub under and open-source license. The key contributions of this work are:

% may need to fix these up a bit
    \begin{itemize}
        \item A tool to study mutant reduction techniques in retrospect.
        \item A tool that accepts a generalised input format.
        \item A tool released as a free and open-source R package.
    \end{itemize}
